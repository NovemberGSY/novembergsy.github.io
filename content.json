{"posts":[{"title":"Maven学习","text":"Maven1、什么是Maven？ Maven是一个项目管理工具，生成报告（日志文件？）和文档的Java项目管理工具，对项目进行构建，依赖管理。（由Apache开发） 将项目开发和管理过程抽象成一个项目对象模型（POM） ，开发人员只需要做一些简单的配置，就可以批量完成项目的构建，报告和文档的生产工具 Alfred在2020年暑期实习期间，做的项目都是基于Maven开发的Web应用（使用SpringMVC开发的Tdogg网上家具商城，Spring Boot开发的Roc鲲鹏航空购票系统） 2、Maven能够做什么？ Maven能够帮助开发者完成一下工作： 构建 文档生成 报告 依赖 SCMs（?） 发布 分发 邮件列表 不使用Maven的情景：一个开发团队需要做大量的前期准备： 确定构架 收集框架相关的jar包 搭建相应框架（SSH、SSM等） 编写测试代码 寻找框架依赖的jar包 剔除冲突的jar包 制定相关文档 …… 以上内容繁琐，需要做非常充分的准备，一只开发团队每承接一个项目，都需要做这一些繁琐的事情，这些事情耗时耗力，又缺少技术含量。 Maven登场，发挥作用： Maven统一集中管理好素有的依赖包，不需要程序员再去寻找 对应的第三方组件用到的jar，Maven自动解决重复和冲突问题。 Maven作为开放的框架，提供公共接口，方便同第三方插件集成。程序员可以将自己需要的插件，动态的集成到Maven，从而扩展新的管理功能。 Maven可以统一每个项目的构建过程，实现不同项目的兼容性管理 3、Maven的特点 项目设置遵循统一的规则。 任意工程中共享。 依赖管理包括自动更新。 一个庞大且不断增长的库。 可扩展，能够轻松编写 Java 或脚本语言的插件。 只需很少或不需要额外配置即可即时访问新功能。 基于模型的构建 − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。 项目信息的一致性站点 − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。 发布管理和发布单独的输出 − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。 向后兼容性 − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。 子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号， 并行构建 − 编译的速度能普遍提高20 - 50 %。 更好的错误报告 − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。 4、POM——Maven工程的基本工作单元 POM(Project Object Model , 项目对象模型)，本质是XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 执行任务或目标时，Maven会在当前目录中查找POM，读取POM，获取所需的配置信息，然后执行目标。 POM中可以指定一下配置： 项目依赖 插件 执行目标 项目构建 profile 项目版本 项目开发者列表 相关邮件列表信息 在pom.xml中，可以看到Maven在执行目标时需要用到的默认工程源码目录结构，输出目录，需要的插件，仓库和报表目录。 5、Maven构建生命周期 一个典型的Maven构建（build）生命周期是由以下几个阶段的序列组成的： 阶段 处理 描述 验证 validate 验证项目 验证项目是否正确且所有必须信息是可用的 编译 compile 执行编译 源代码编译在此阶段完成 测试 Test 测试 使用适当的单元测试框架（例如JUnit）运行测试。 包装 package 打包 创建JAR/WAR包如在 pom.xml 中定义提及的包 检查 verify 检查 对集成测试的结果进行检查，以保证质量达标 安装 install 安装 安装打包的项目到本地仓库，以供其他项目使用 部署 deploy 部署 拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程 （以上表格采用自“菜鸟教程”） 链接：https://www.runoob.com/maven/maven-build-life-cycle.html 这些阶段将被按顺序地执行。Maven有一下三个标准的生命周期： clean：项目清理的处理 default（或build）：项目部署的处理 site：项目站点文档创建的处理 Clean生命周期 当我们执行 1mvn post-clean 命令时 Maven调用 clean 生命周期，它包含以下阶段： Pre-clean : 执行一些需要在clean之前完成的工作 clean：移除所有上一次构建生成的文件 post-clean：执行一些需要在clean之后立刻完成的工作","link":"/2020/09/23/Maven%E5%AD%A6%E4%B9%A0/"},{"title":"Redis 学习","text":"Redis学习1、Redis是什么？ Redis的全称是**(REmote DIctionary Server 远程字典服务)**，是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的，使用ANSI（C语言标准） C语言编写，遵守BSD（“Berkeley Software Distribution”伯克利软件发行版）协议，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并且提供多种语言的API。 Redis通常被称为数据结构服务器，因为其可以存储的值（Value）可以是 String 字符串 Hash 哈希 List 列表 Sets 集合 Sorted sets 有序集合 相关链接： Redis 官网：https://redis.io/ Redis 在线测试：http://try.redis.io/ Redis 命令参考：http://doc.redisfans.com/ 2、Redis能做什么？ Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash等数据结构的存储 Redis支持数据的备份，即master-slave模式的数据备份 3、为什么选择使用Redis？关于Redis的优势： 性能极高 —— Redis能读的速度是110000次/s，写的速度是81000次/s。 丰富的数据类型 —— Redis支持二进制案例的String，Lists，Hashes，Sets 及 Ordered Sets 数据类型操作。 原子 —— Redis的所有操作系统都是原子性的，意思就是要么成功执行，要么失败完全不执行。单个操作是原子性的。 丰富的特性 —— Redis还支持 publish/subscribe，通知，key过期等等特性。 Redis与其他key - value 存储有什么不同？ Redis更为复杂的数据结构并且提供对这些数据结构的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的，同时对于程序眼透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 4、Redis的相关命令 启动Redis（需要切换到安装Redis的bin/目录下） 1$ ./redis-server 启动Redis 启动成功后的界面如下： 查看Redis状态（是否启动，是否使用成功） 1$ redis-cli 该命令会链接本地的Redis服务 关闭Redis 12$ redis-cli 进入Redis服务$ shutdown save｜nosave 系统会提示保存还是不保存 关于 save 和 nosave SHUTDOWN SAVE能够在即使没有配置持久化的情况下强制数据库存储. SHUTDOWN NOSAVE 能够在配置一个或者多个持久化策略的情况下阻止数据库存储. (你可以假想它为一个中断服务的 ABORT 命令).","link":"/2020/09/28/Redis%E5%AD%A6%E4%B9%A0/"},{"title":"Servlet","text":"Servlet Servlet主要用于处理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有doGet()和doPost()等方法。 Servlet由Servlet容器提供，所谓的Servlet容器是指提供了Servlet 功能的服务器（例如Tomcat），Servlet容器将Servlet动态的加载到服务器上。与HTTP 协议相关的Servlet使用HTTP请求和HTTP响应与客户端进行交互。因此，Servlet容器支持所有HTTP协议的请求和响应。Servlet应用程序的体系结构如图所示。 ![image-20200825092752267](/Users/louwenbo/Library/Application Support/typora-user-images/image-20200825092752267.png) Servlet的请求首先会被HTTP服务器接收，HTTP服务器只负责静态HTML页面的解析，对于Servlet的请求转交给Servlet容器，Servlet容器会根据web.xml文件中的映射关系，调用相应的Servlet，Servlet将处理的结果返回给Servlet容器，并通过HTTP服务器将响应传输给客户端。 Servlet技术具有如下特点： 方便：Servlet提供了大量的实用工具例程，如处理很难完成的HTML表单数据、读取和设置HTTP头，以及处理Cookie和跟踪会话等。 跨平台：Servlet用Java类编写，可以在不同操作系统平台和不同应用服务器平台下运行。 灵活性和可扩展性：采用Servlet开发的Web应用程序，由于Java类的继承性及构造函数等特点，使得应用灵活，可随意扩展。","link":"/2020/08/25/Servlet/"},{"title":"Spring","text":"1、Spring 1.1、简介(用于面试) 2002年首次推出了Spring框架的雏形 “不要重复发明轮子（Don’t Reinvent Wheel）”,意思是企业中任何一项工作实际上都有人做过，软件领域中有的功能或者是项目，别人已经做过，我们需要用的时候，直接拿来用即可，而不需要重新创造。可以很好的来解释Spring框架。 Spring保持强大的向后兼容性。 解决企业应用开发的复杂性 Spring是一个轻量级控制反转（IoC）和面向切面（AOP）的容器框架 Spring的理念：使现有的技术更加容易使用 SSH（Struct2 + Spring + Hibernate） SSM(Spring + SpringMVC + Mybatis) 1.2、优点、缺点 优点 开源免费框架（容器） 轻量级，非侵入式的框架 控制反转（IoC），面向切面编程（AOP） 缺点 发展太久之后，违背了原来的理念，配置非常繁琐。（很多同学都在Spring的配置文件上劝退了） 1.3、组成 1.4、拓展 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置（COC） Spring Cloud SpringCloud是基于SpringBoot实现的 目前很多大公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC 2、IoC理论推导 UserDao接口 UserDaoImpl实现类 UserService业务接口 UserServiceImpl业务员实现类 在之前所学习的编程里（例如 JavaSE），用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码，如果程序代码量十分大，修改一次的成本代价十分昂贵。 例如在2020年1-4月份期间自己独立开发（Visual Basic）的排版系统，编写的变量，常量非常多，如果遇到一些特殊的需求（因为疫情会改变排版的基本需求），程序不能满足的话，需要回到源代码的层面上去更改数据，难免是麻烦的，甚至在一些设计不周的情况下出现意想不到的bug。 之前，程序是主动创建对象，控制权在程序员手上 使用了一些方法（例如Set注入），程序不再具有主动性，而是变成了被动的接受对象 这种思想，从本质上解决了问题，程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以使开发更加注重在业务的实现上，这是IoC的原型。 3、IoC本质 控制反转IoC（Inversion of Control）,是一种设计思想，DI依赖注入（Dependence Injection）是实现IoC的方法。在没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 采用XML方式配置Bean的时候，Bean的定义信息是和现实分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。","link":"/2020/09/09/Spring%E5%AD%A6%E4%B9%A0/"},{"title":"","text":"title:Vim 快捷指令图","link":"/2023/02/08/Vim-%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4%E5%9B%BE/"},{"title":"云服务器相关","text":"shell 进程查看： 1ps aux tomcat实时日志查看： 1234先切换到tomcat的logs目录：cd /usr/local/tomcat/logstail -f catalina.out然后Ctrl+c退出tail","link":"/2020/08/14/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B/"},{"title":"选择排序","text":"选择排序是最为稳定的排序算法之一，无论什么数据进去时间复杂度都为O(n^2)。 动画演示如下：(引用自网站)https://www.cnblogs.com/onepixel/articles/7674659.html#!comments 代码如下： 123456789101112131415161718192021222324252627282930313233import java.util.Arrays;public class SelectionSort { //选择排序 public static int[] SelectionSort(int arr[]){ int index; //记录最小数的下标 int temp; //数据交换使用的临时变量 for (int i = 0; i &lt; arr.length - 1; i++) { index = i; for (int j = i; j &lt; arr.length; j++) { if (arr[j] &lt; arr[index]){ index = j; //记录最小的下标 } } temp = arr[i]; //交换数据 arr[i] = arr[index]; arr[index] = temp; } return arr; } public static void main(String[] args) { int arr[] = new int[]{5,79,32,74,35,76,33,15,6,0}; int arr1[] = new int[]{231,345,7654,23421,875,90,42,123,532}; int arr2[] = new int[]{1,3,2,5,4,7,6,9,9,10}; SelectionSort(arr); SelectionSort(arr1); SelectionSort(arr2); System.out.println(Arrays.toString(arr)); System.out.println(Arrays.toString(arr1)); System.out.println(Arrays.toString(arr2)); }} 运行结果如下： 12345[0, 5, 6, 15, 32, 33, 35, 74, 76, 79][42, 90, 123, 231, 345, 532, 875, 7654, 23421][1, 2, 3, 4, 5, 6, 7, 9, 9, 10]Process finished with exit code 0","link":"/2020/10/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"title":"冒泡排序","text":"记录一下自己学习的过程，不足之处待谅解😁 1234567891011121314151617181920212223242526272829import java.util.*;public class test { //冒泡排序 public static int[] BubbleSort(int arr[]){ int small = 0; //临时变量储存较小的数据 for (int j = 0;j&lt; arr.length;j++) { //冒泡趟数 for (int i = 1; i &lt; arr.length - j; i++) {//从第二项（arr[1]）开始排序，防止溢出报错 if (arr[i - 1] &gt; arr[i]) { //判断 small = arr[i]; //交换数据 arr[i] = arr[i - 1]; arr[i - 1] = small; } } } return arr; } public static void main(String[] args) { int[] arr = new int[]{5,79,32,74,35,76,33,15,6,0}; int[] arr1 = new int []{231,345,7654,23421,875,90,42,123,532}; BubbleSort(arr); for (int i = 0; i &lt; arr.length; i++) { //for循环输出方法 System.out.print(arr[i] + &quot; &quot;); } System.out.println(); BubbleSort(arr1); System.out.println(Arrays.toString(arr1)); //更简单的输出方法Arrays.toString }} 运行结果： 123450 5 6 15 32 33 35 74 76 79 //for 循环输出[42, 90, 123, 231, 345, 532, 875, 7654, 23421] //Arrays.toString输出Process finished with exit code 0","link":"/2020/10/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"title":"Git 命令总结","text":"Git 命令总结推荐以玩游戏学习git的网站：https://learngitbranching.js.org/?locale=zh_CN 首先需要安装git工具，安装教程跳过 1$ git 或者 12$ git --versiongit version 2.21.0 (Apple Git-122) 创建git仓库12$ git initInitialized empty Git repository in /***/****/** 当前文件夹下，会多一个 .git 文件，千万不可手动修改，不然git仓库会被破坏。 git克隆1$ git clone https://github.com/***/*** （git仓库地址） 创建&amp;切换分支12$ git checkout -b dev(branch-name)Switched to a new branch 'dev' 到这里，本地新建了一个 dev 分支，并且已经切换过去了。 解释一下：这里 git checkout 命令加上-b参数，表示创建并切换，相当于一下两个命令： 123$ git branch dev$ git checkout devSwitched to branch 'dev' 注意：刚刚git init命令执行完后，直接执行git branch (branch-name)是无效的，创建分支失败，需要先进行一次本地提交。 本地添加，提交123$ git add . //本地仓库添加$ git commit -m &quot;first commit&quot; // 本地提交$ git branch dev 融合分支1$ git merge dev(target-branch） //将dev分支合并到当前分支 删除分支1$ git branch -d dev(branch-nme) //删除dev分支 查看 git log 日志12$ git log //查看log日志 进入日志后，输入q退出查看界面...... 关联远程分支,然后推上去12345$ git remote add origin https://......git(url) //关联远程分支$ git push origin -u dev(branch-name) //把本地dev分支推到远程仓库并且命名为dev//另一种，但是不常用$ git push origin -u dev:sit //把本地dev分支推送到远程名为origin到远程仓库，并且创建远程分支为sit，该分支跟踪本地分支dev, -u 选项设置了上游关系，以后可以使用命令 git push 直接推送到该sit分支","link":"/2023/02/03/Git%20%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"}],"tags":[],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[]}